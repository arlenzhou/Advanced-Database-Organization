<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en-us"><head>
   <meta content="text/html; charset=UTF-8" http-equiv="content-type">
   <title>CS 525 - assign4</title>
   <meta name="author" content="Boris Glavic">

   <link href="files/site.css" rel="stylesheet" media="screen, projection" type="text/css">
<link rel="stylesheet" href="http://yandex.st/highlightjs/7.3/styles/default.min.css">
<script src="http://yandex.st/highlightjs/7.3/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<!-- ************************************************************ -->
<!-- ************* Menu ***************************************** -->
<!-- ************************************************************ -->
</head>
<body id="home">
  <div class="header">
    <h1><strong>CS 525</strong>: Advanced Database Organization - <it>Spring 2014</it></h1>
    <div class="iitlink">
      <a href="http://www.iit.edu/csl" target="_blank">
      <img src="./files/iit_logo_white.png" border="0" style="border:none;max-width:100%"  height="60px" alt="IIT logo" />
      </a>
    </div>
    <div class="unilinks">
      <ul>
	<li>
	<a href="http://www.iit.edu/csl/cs" target="_blank"><img src="./files/CS_600w.jpg" border="0" style="border:none;max-width:100%" height="60px" alt="CS logo" /></a>
	</li>
	<li>
	<a href="http://www.iit.edu/csl" target="_blank"><img src="./files/CSL_logo_white.png" border="0" style="border:none;max-width:100%"  height="60px" alt="CSL logo" /></a>
	</li>
      </ul>
    </div>
    <ol id="navbar">
      <li id="nav_home"><a href="http://cs.iit.edu/%7ecs525/index.html">Home</a></li>
      <li id="nav_lectures"><a href="http://cs.iit.edu/%7ecs525/info.html">Course Info</a></li>
      <li id="nav_schedule"><a href="http://cs.iit.edu/%7ecs525/schedule.html">Schedule</a></li>
      <li id="nav_assignments"><a href="http://cs.iit.edu/%7ecs525/assignments.html">Programming Assignments</a></li>
      <li id="nav_quiz"><a href="http://cs.iit.edu/%7ecs525/quiz.html">Quizzes</a></li>
      <li id="nav_final"><a href="http://cs.iit.edu/%7ecs525/final.html">Exams</a></li>
      <li id="nav_resources"><a href="http://cs.iit.edu/%7ecs525/resources.html">Resources</a></li>
    </ol>
  </div>

  <!-- ************************************************************ -->  
<!-- ************* Content ************************************** -->
<!-- ************************************************************ -->  
  <div id="content">
<h2>Assignment 4 - B+-Tree</h2>

<p>In this assignment you are implementing a B+-tree index. The index should be backed up by a page file and pages of the index should be accessed through your buffer manager. As discussed in the lecture each node should occupy one page. However, for debugging purposes you should support trees with a smaller fan-out and still let each node occupy a full page. A B+-tree stores pointer to records (the <tt>RID</tt> introduced in the last assignment) index by a keys of a given datatype. The assignment only requires you to support <tt>DT_INT</tt> (integer) keys (see optional extensions). Pointers to intermediate nodes should be represented by the page number of the page the node is stored in. To make testing easier your implementation should follow the conventions stated below.</p>

<ul>
	<li><strong>Leaf Split</strong>: In case a leaf node need to be split during insertion and <tt>n</tt> is even, the left node should get the extra key. E.g, if <tt>n = 2</tt> and we insert a key 4 into a node <tt>[1,5]</tt>, then the resulting nodes should be <tt>[1,4]</tt> and <tt>[5]</tt>. For odd values of <tt>n</tt> we can always evenly split the keys between the two nodes. In both cases the value inserted into the parent is the smallest value of the right node.</li>
	<li><strong>Non-Leaf Split</strong>: In case a non-leaf node needs to be split and <tt>n</tt> is odd, we cannot split the node evenly (one of the new nodes will have one more key). In this case the &quot;middle&quot; value inserted into the parent should be taken from the right node. E.g., if <tt>n = 3</tt> and we have to split a non-leaf node <tt>[1,3,4,5]</tt>, the resulting nodes would be <tt>[1,3]</tt> and <tt>[5]</tt>. The value inserted into the parent would be <tt>4</tt>.</li>
	<li><strong>Leaf Underflow</strong>: In case of a leaf underflow your implementation should first try to <tt>redistribute</tt> values from a sibling and only if this fails merge the node with one of its siblings. Both approaches should prefer the left sibling. E.g., if we can borrow values from both the left and right sibling, you should borrow from the left one.</li>
</ul>

<p>You can use the B+-tree shown below to sanity check your implementation of inserts. It has been generated by the following sequence of key insertions <tt>1,11,13,17,23,52</tt> for RIDs <tt>1.1,2.3,1.2,3.5,4.4,3.2</tt>.</p>

<embed src="files/BtreeEx.svg" type="image/svg+xml" class="aligncenter" width="450"/>

<!-- ************************************************************ -->
<h3>Interface</h3>

<pre><code>#ifndef BTREE_MGR_H
#define BTREE_MGR_H

#include "dberror.h"
#include "tables.h"

// structure for accessing btrees
typedef struct BTreeHandle {
  DataType keyType;
  char *idxId;
  void *mgmtData;
} BTreeHandle;

typedef struct BT_ScanHandle {
  BTreeHandle *tree;
  void *mgmtData;
} BT_ScanHandle;

// init and shutdown index manager
extern RC initIndexManager (void *mgmtData);
extern RC shutdownIndexManager ();

// create, destroy, open, and close an btree index
extern RC createBtree (char *idxId, DataType keyType, int n);
extern RC openBtree (BTreeHandle **tree, char *idxId);
extern RC closeBtree (BTreeHandle *tree);
extern RC deleteBtree (char *idxId);

// access information about a b-tree
extern RC getNumNodes (BTreeHandle *tree, int *result);
extern RC getNumEntries (BTreeHandle *tree, int *result);
extern RC getKeyType (BTreeHandle *tree, DataType *result);

// index access
extern RC findKey (BTreeHandle *tree, Value *key, RID *result);
extern RC insertKey (BTreeHandle *tree, Value *key, RID rid);
extern RC deleteKey (BTreeHandle *tree, Value *key);
extern RC openTreeScan (BTreeHandle *tree, BT_ScanHandle **handle);
extern RC nextEntry (BT_ScanHandle *handle, RID *result);
extern RC closeTreeScan (BT_ScanHandle *handle);

// debug and test functions
extern char *printTree (BTreeHandle *tree);

#endif // BTREE_MGR_H
</pre></code>

<!-- ************************************************************ -->
<h4>Index Manager Functions</h4>

<p>These functions are used to initialize the index manager and shut it down, freeing up all acquired resources.</p>

<!-- ************************************************************ -->
<h4>B+-tree Functions</h4>

<p>These functions are used to create or delete a b-tree index. The later should also remove the corresponding page file. Furthermore, before a client can access an b-tree index it has to be opened (<tt>openBtree</tt>). When closing a b-tree (<tt>closeBtree</tt>), the index manager should ensure that all new or modified pages of the index are flushed back to disk (use the buffer manager function for that).</p>

<!-- ************************************************************ -->
<h4>Key Functions</h4>

<p>These functions are used to find, insert, and delete keys in/from a given B+-tree. <tt>findKey</tt> return the <tt>RID</tt> for the entry with the search key in the b-tree. If the key does not exist this function should return <tt>RC_IM_KEY_NOT_FOUND</tt> (see <tt>dberror.h</tt>). <tt>insertKey</tt> inserts a new key and record pointer pair into the index. It should return error code <tt>RC_IM_KEY_ALREADY_EXISTS</tt> if this key is already stored in the b-tree. <tt>deleteKey</tt> removes a key (and corresponding record pointer) from the index. It should return <tt>RC_IM_KEY_NOT_FOUND</tt> if the key is not in the index. For deletion it is up to the client whether this is handled as an error.</p>

<p>Furthermore, clients can scan through all entries of a BTree in sort order using the <tt>openTreeScan</tt>, <tt>nextEntry</tt>, and <tt>closeTreeScan</tt> methods. The <tt>nextEntry</tt> method should return <tt>RC_IM_NO_MORE_ENTRIES</tt> if there are no more entries to be returned (the scan has gone beyond the last entry of the B+-tree. Below is an example of how the scan can be used.</p>

<pre><code>
  BT_ScanHandle *sc;
  RID rid;
  int rc;

  startTreeScan(btree, sc, NULL);
  
  while((rc = nextEntry(sc, &rid)) == RC_OK) 
    {
    // do something with rid
    }
    if (rc != RC_IM_NO_MORE_ENTRIES)
       // handle the error
  closeTreeScan(sc);
</code></pre>

<!-- ************************************************************ -->
<h4>Debug functions</h4>

<p><tt>printTree</tt> is used to create a string representation of a b-tree. It is used in the test cases and can be helpful for debugging. You code <strong>has to</strong> generate the format described in the following. Each node of a b-tree is represented as one line in the string representation. The order of nodes should be in depth-first pre-order. The following representation should be used for each node <tt>(pos)[pointer,key,pointer, ...]</tt>. Key should be represented using the serializeValue method from the last assignment. Pointers to nodes should be shown as the node position according to depth first pre-order traversal. Thus, the string representations generated by <tt>printTree</tt> is independent of the actual positions of the index nodes on disk. <tt>RID</tt>s should be represented as <tt>PageNumber.Slot</tt>. As an example consider the b-tree shown below and its string representation.</p>

<embed src="files/BtreeEx.svg" type="image/svg+xml" class="aligncenter" width="450"/>

<pre>
(0)[1,13,2,23,3]
(1)[1.1,1,2.3,11,2]
(2)[1.2,13,3.5,17,3]
(3)[4.4,23,3.2,52]
</pre>

<!-- ************************************************************ -->
<h3 id="optional">Optional Extensions</h3>

<p><strong>Integrate the B+-tree with the record manager</strong>: Modify your record manager to use the B+-tree for search. That is when creating a new relation with the record manager you should let the user specify which attribute is the key of the table. The record manager should then create and maintain the B+-tree for storing the keys from this attribute. When a new record is inserted, the corresponding key should be inserted in the B+-tree. A scan that searches for a record with a given key should use the B+-tree instead of scanning through all the records. If you want to support keys with more than one attribute, you are allowed to change the b-tree interface to support that.</p>

<p><strong>Allow different data types as keys</strong>: Allow the other data types introduced in assignment 3 to be used as keys for the B+-tree.</p>

<p><strong>Implement pointer swizzling</strong>: Once a B-tree node is memory, conceptual pointers to that node (<tt>pagenum</tt>) should be actual memory pointers. Note that B-trees pages are only pointed to by their intermediate parent node. Thus, a simple way to realize swizzling at page load time, is to immediately replace the pointer to a child node with the memory pointer once some code tries to access it. The complicated part is to make sure that memory pointers are replaced with <tt>pagenum</tt> if the buffer manager evicts a page from the buffer that was pointed to by a memory pointer. A reasonable way to implement this is to create a bookkeeping data structure that stores all places of pointers to a node that have been replaced by memory pointers. The buffer manager has to be extended with a callback function parameter. This callback is called whenever a page is evicted. For this extension the callback would be a clean-up function that accesses the bookkeeping data structure to figure out where it has to replace memory pointers with page numbers. This data structure is also needed when a node gets evicted that has memory pointer to one or more of its child nodes.</p>

<p><strong>Support multiple entries for one key</strong>: Instead of enabling only a single <tt>RID</tt> to be stored for each key, allow insertions of multiple entries with the same key. You are allowed to change the <tt>btree_mgr.h</tt> to support accessing all the entries for a key. Please do not change the signature of the <tt>findKey</tt> method, but rather add a new <tt>findAllEntries</tt> method that returns an array/list of entries. The <tt>findKey</tt> should return the first entry only. Instead of <tt>RIDs</tt> the pointers in leave nodes should reference a page storing all entries for a key. If there are more entries for a key then you can fit onto one page, additional pages should be organized as a linked list. That is each page stores a pointer to the next page.</p>

<!-- ************************************************************ -->
<h3>Source Code Structure</h3>

Your source code directories should be structured as follows. You should reuse your existing storage manager and buffer manager implementations (also record manager if you plan to implement the record manager integration extension). So before you start to develop, please copy these implementations into the assign4 folder.

<ul>
	<li>Put all source files in a folder <tt>assign4</tt> in your git repository</li>
	<li>This folder should contain at least ...</li>
	<ul>
		<li>the provided header and C files</li>
		<li>a make file for building your code <tt>Makefile</tt></li>
		<li>a bunch of <tt>*.c</tt> and <tt>*.h</tt> files implementing the B+-tree</li>
		<li><tt>README.txt</tt>: A text file that shortly describes your solution</li>
	</ul>
</ul>

E.g., the structure may look like that:

<pre><code>git
	assign4
		Makefile
	    buffer_mgr.c
	    buffer_mgr.h
	    buffer_mgr_stat.c
	    buffer_mgr_stat.h
		btree_mgr.c
		btree_mgr.h
		dberror.c
		dberror.h
	    dt.h
		expr.c
		expr.h
		record_mgr.c
		record_mgr.h
		rm_serializer.c
		storage_mgr.h
		tables.h
		test_assign4_1.c
		test_expr.c
		test_helper.h
</code></pre>


<!-- ************************************************************ -->
<h3>Test Cases</h3>

<h4><tt>test_helper.h</tt></h4>

<p>Defines several helper methods for implementing test cases such as <tt>ASSERT_TRUE</tt>.</p>

<h4><tt>test_expr.c</tt></h4>

<p>This file implements several test cases using the <tt>expr.h</tt> interface. Please let your make file generate a <tt>test_expr</tt> binary for this code. You are encouraged to extend it with new test cases or use it as a template to develop your own test files.</p>

<h4><tt>test_assign4_1.c</tt></h4>

<p>This file implements several test cases using the <tt>btree_mgr.h</tt> interface. Please let your make file generate a <tt>test_assign4</tt> binary for this code. You are encouraged to extend it with new test cases or use it as a template to develop your own test files.</p>


<script>

var pres = document.getElementsByClassName('blockcode'), pre, code, lines, pl, cl;

for (pl = pres.length, p = 0; p < pl; p++) {

pre = pres[p];

code = pre.children[0];

code.innerHTML = code.innerHTML.split("\n").map(function(line) {

return '<span class="line">' + line + '</span>';

}).join("\n");

lines = code.getElementsByClassName('line');

for (cl = lines.length, l = 0; l < cl; l++) {

lines[l].style.width = pre.scrollWidth + 'px';

}

}

</script>
  </div>
<!-- ************************************************************ -->
<!-- ************* Footer ************************************** -->
<!-- ************************************************************ -->  
  <div id="footer">
   <p>
     <a href="mailto:bglavic@iit.edu">bglavic@iit.edu</a>.<br>
   </p> 
  </div>
  <script type="text/javascript">
  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
  </script><script src="syllabus_files/ga.js" type="text/javascript"></script>
  <script type="text/javascript">
  try {
  var pageTracker = _gat._getTracker("UA-7056528-7");
  pageTracker._trackPageview();
  } catch(err) {}</script>


</body></html>
